# Module 4: databases

## This module demonstrates database modelling for the univercity

## Design

Let's design the simple database with 3 tables: students, subjects and exam_results. Students and Subjects tables both has id as the primary key which is foreign key in Exam results table and demonstrates one-to-many relationship, so each result can be identified by participating of single student in single subject. 

![alt text](design.png)

Let's create physical model of the database in postgress. SQL for tables creation can be checked in [create_db.sql](create_db.sql). There were added some constraints as nullability checks, check that phone number is 11 symbols, uniqueness of the subject name/phone number and range for the mark between 1 and 5 inclusively.

## Generating the mock data

We need to populate tables with huge amount of data for index analysis task. At the beginning I generated everything randomly with the [mock_data.sql](mock_data/mock_data.sql) script, but as I used md5 hash function my data did not look as the real world, so finally the https://www.mockaroo.com/ service was used to generate some fields as name, surname, full name of tutor, subject name (as movie title because Mockaroo does not have it) and primary skill as linkedin skill. The final CSV was generated by randomly getting data from Mockaroo CSV and  other fields randomly generated with the python script [mock_data.py](mock_data/mock_data.py).

## Index analysis

Let's check index sizes right after feeeding the data before creating any custom index. We can use the following command to check it:

```sql
select indexrelname "Index name", pg_size_pretty(pg_relation_size(indexrelid)) "Index size", amname "Index type"
from pg_stat_all_indexes sai
join pg_class c ON sai.indexrelid=c.oid
join pg_am am ON c.relam=am.oid
where sai.relname in ('students', 'subjects', 'exam_results');
```

We can see postgress created indexes for primary keys and unique columns with btree type:

|"Index name"|"Index size"|"Index type"|
|---|---|---|
|"students_pkey"|"2208 kB"|"btree"|
|"students_phone_number_key"|"4360 kB"|"btree"|
|"subjects_pkey"|"40 kB"|"btree"|
|"subjects_subject_name_key"|"88 kB"|"btree"|

Let's compare custom index types: size and creation time. For gist and gin indexes we need to enable few extensions:

```sql
create extension btree_gin;
create extension btree_gist;
create extension pg_trgm;
```

Let's create btree/hash/gin/gist indexes for few different columns from tables. For text columns we can use trigram option of gin/gist which is better suitable for the text search.

```sql
create index students_name_btree on students using btree(name);
create index students_name_hash on students using hash(name);
create index students_name_gin on students using gin(name);
create index students_name_gin_trgm on students using gin(name gin_trgm_ops);
create index students_name_gist on students using gist(name);
create index students_name_gist_trgm on students using gist(name gist_trgm_ops);

create index subjects_subject_name_btree on subjects using btree(subject_name);
create index subjects_subject_name_hash on subjects using hash(subject_name);
create index subjects_subject_name_gin on subjects using gin(subject_name);
create index subjects_subject_name_gin_trgm on subjects using gin(subject_name gin_trgm_ops);
create index subjects_subject_name_gist on subjects using gist(subject_name);
create index subjects_subject_name_gist_trgm on subjects using gist(subject_name gist_trgm_ops);

create index exam_results_mark_btree on exam_results using btree(mark);
create index exam_results_mark_hash on exam_results using hash(mark);
create index exam_results_mark_gin on exam_results using gin(mark);
create index exam_results_mark_gist on exam_results using gist(mark);
```

Results:

|"Index name"|"Index size"|"Index type"|"Creation time"|
|---|---|---|---|
|"students_name_btree"|"712 kB"|"btree"|105 ms|
|"students_name_hash"|"4536 kB"|"hash"|121 ms|
|"students_name_gin"|"520 kB"|"gin"|93 ms|
|"students_name_gin_trgm"|"2248 kB"|"gin"|162 ms|
|"students_name_gist"|"4312 kB"|"gist"|2 819 ms|
|"students_name_gist_trgm"|"5992 kB"|"gist"|1 126 ms|
|"subjects_subject_name_btree"|"72 kB"|"btree"|51 ms|
|"subjects_subject_name_hash"|"48 kB"|"hash"|35 ms|
|"subjects_subject_name_gin"|"120 kB"|"gin"|34 ms|
|"subjects_subject_name_gin_trgm"|"288 kB"|"gin"|36 ms|
|"subjects_subject_name_gist"|"80 kB"|"gist"|40 ms|
|"subjects_subject_name_gist_trgm"|"184 kB"|"gist"|39 ms|
|"exam_results_mark_btree"|"6792 kB"|"btree"|532 ms|
|"exam_results_mark_hash"|"47 MB"|"hash"|32 218 ms|
|"exam_results_mark_gin"|"1136 kB"|"gin"|190 ms|
|"exam_results_mark_gist"|"42 MB"|"gist"|1 599 ms|

In the result table for the student name field we can see that gist index is the slowest one for creation. Also, this index takes the most storage for both versions as well as trigram version of gin index. What can be weird from the first sight is that hash index takes much more place than btee index, actually even more than both gin and gist without trigram support. The explanation is that we have only 1000 different names for 100 000 studens and hash index does not work well for cases with many rows and few distinct values. In this case there are not enough buckets to make this type of index usable.

Let's take a look on subject name from the subjects table. The situation with the hash index is much better. As the subject is unique, the hash function distibution is really well, there are no collisions. So index in this case is 50% smaller compare to btree. We can ask why postgres did not choose hash index for default indexes created automatically for unique fields. The answer is that has index can work only for strict comparison cases (= operator) and btree index is more flexible as supports greater and lower than comparisons in queries (> and < operators). Creation time is basically the same for all cases as there are just 1000 rows in this table. For the same reason it does not make sense to analyse indexes creation time before inserting data in tables. Also, we can see the trigram indexes takes the most space as in the previous case.

By analysing indexes on the mark column from the exam_results cases we can see the very bad scenario for the hash index - there just 5 distinct values for the mark and one million rows. It did not just a lot of space (47 MB), but also it took half a minute to create hash index! Besides that we can see that gin index took less space even than btree and gist index took significan amount comparable to the hash index case.

Let's drop our indexes and start analysing different query perfomance with different indexes by creating and removing indexes one by one.

```sql
drop index students_name_btree;
drop index students_name_hash;
drop index students_name_gin;
drop index students_name_gin_trgm;
drop index students_name_gist;
drop index students_name_gist_trgm;

drop index subjects_subject_name_btree;
drop index subjects_subject_name_hash;
drop index subjects_subject_name_gin;
drop index subjects_subject_name_gin_trgm;
drop index subjects_subject_name_gist;
drop index subjects_subject_name_gist_trgm;

drop index exam_results_mark_btree;
drop index exam_results_mark_hash;
drop index exam_results_mark_gin;
drop index exam_results_mark_gist;
```

## Queries perfomance analysis
A) exact match by name:

```sql
explain analyse select * from students where name = 'Mora'
```

No index
```
"Seq Scan on students  (cost=0.00..2420.00 rows=99 width=62) (actual time=0.017..6.567 rows=95 loops=1)"
"  Filter: ((name)::text = 'Mora'::text)"
"  Rows Removed by Filter: 99905"
"Planning Time: 0.044 ms"
"Execution Time: 6.578 ms"
```

BTree
```
"Bitmap Heap Scan on students  (cost=5.06..305.09 rows=99 width=62) (actual time=0.034..0.137 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_btree  (cost=0.00..5.04 rows=99 width=0) (actual time=0.021..0.021 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.074 ms"
"Execution Time: 0.162 ms"
```

Hash
```
"Bitmap Heap Scan on students  (cost=4.77..304.79 rows=99 width=62) (actual time=0.019..0.090 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_hash  (cost=0.00..4.74 rows=99 width=0) (actual time=0.008..0.008 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.050 ms"
"Execution Time: 0.104 ms"
```

Gin
```
"Bitmap Heap Scan on students  (cost=12.77..312.79 rows=99 width=62) (actual time=0.032..0.122 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_gin  (cost=0.00..12.74 rows=99 width=0) (actual time=0.020..0.020 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.141 ms"
"Execution Time: 0.143 ms"
```

Gin trigram
```
"Bitmap Heap Scan on students  (cost=44.77..344.79 rows=99 width=62) (actual time=0.130..0.197 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_gin_trgm  (cost=0.00..44.74 rows=99 width=0) (actual time=0.119..0.119 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.110 ms"
"Execution Time: 0.212 ms"
```

Gist
```
"Bitmap Heap Scan on students  (cost=5.05..305.07 rows=99 width=62) (actual time=0.072..0.138 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_gist  (cost=0.00..5.02 rows=99 width=0) (actual time=0.062..0.062 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.102 ms"
"Execution Time: 0.157 ms"
```

Gist trigram
```
"Bitmap Heap Scan on students  (cost=5.05..305.07 rows=99 width=62) (actual time=2.028..2.123 rows=95 loops=1)"
"  Recheck Cond: ((name)::text = 'Mora'::text)"
"  Heap Blocks: exact=94"
"  ->  Bitmap Index Scan on students_name_gist_trgm  (cost=0.00..5.02 rows=99 width=0) (actual time=1.999..1.999 rows=95 loops=1)"
"        Index Cond: ((name)::text = 'Mora'::text)"
"Planning Time: 0.124 ms"
"Execution Time: 2.166 ms"
```

We can see that all indexes speed up search more or less same well and give us 30-60 times perfomance gain except Gist trigram index which only 3 times faster than search without any index.

B) partial match by surname

```sql
explain analyze select * from students where surname like '%ram%'
```

No index
```
"Seq Scan on students  (cost=0.00..2420.00 rows=9 width=62) (actual time=0.008..9.874 rows=197 loops=1)"
"  Filter: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Filter: 99803"
"Planning Time: 0.051 ms"
"Execution Time: 9.890 ms"
```

BTree
```
"Seq Scan on students  (cost=0.00..2420.00 rows=9 width=62) (actual time=0.007..10.114 rows=197 loops=1)"
"  Filter: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Filter: 99803"
"Planning Time: 0.646 ms"
"Execution Time: 10.128 ms"
```

Hash
```
"Seq Scan on students  (cost=0.00..2420.00 rows=9 width=62) (actual time=0.007..9.851 rows=197 loops=1)"
"  Filter: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Filter: 99803"
"Planning Time: 0.097 ms"
"Execution Time: 9.864 ms"
```

Gin
```
"Seq Scan on students  (cost=0.00..2420.00 rows=9 width=62) (actual time=0.007..9.662 rows=197 loops=1)"
"  Filter: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Filter: 99803"
"Planning Time: 0.077 ms"
"Execution Time: 9.676 ms"
```

Gin trigram
```
"Bitmap Heap Scan on students  (cost=12.07..45.82 rows=9 width=62) (actual time=0.091..0.457 rows=197 loops=1)"
"  Recheck Cond: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Index Recheck: 183"
"  Heap Blocks: exact=321"
"  ->  Bitmap Index Scan on students_surname_gin_trgm  (cost=0.00..12.07 rows=9 width=0) (actual time=0.056..0.056 rows=380 loops=1)"
"        Index Cond: ((surname)::text ~~ '%ram%'::text)"
"Planning Time: 0.146 ms"
"Execution Time: 0.480 ms"
```

Gist
```
"Seq Scan on students  (cost=0.00..2420.00 rows=9 width=62) (actual time=0.009..9.466 rows=197 loops=1)"
"  Filter: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Filter: 99803"
"Planning Time: 0.069 ms"
"Execution Time: 9.481 ms"
```

Gist trigram
```
"Bitmap Heap Scan on students  (cost=4.35..38.09 rows=9 width=62) (actual time=4.276..4.495 rows=197 loops=1)"
"  Recheck Cond: ((surname)::text ~~ '%ram%'::text)"
"  Rows Removed by Index Recheck: 183"
"  Heap Blocks: exact=321"
"  ->  Bitmap Index Scan on students_surname_gist_trgm  (cost=0.00..4.35 rows=9 width=0) (actual time=4.247..4.247 rows=380 loops=1)"
"        Index Cond: ((surname)::text ~~ '%ram%'::text)"
"Planning Time: 0.106 ms"
"Execution Time: 4.517 ms"
```

We can see that only trigram versions of Gin and Gist indexes were really used in the search. Every other index does not support 'like' operator. Also, we see that Gist trigram perfomance gain was only 2 times faster, but Gin trigram around 20.

C) partial match by phone number

This case should be exactly same as previous. Let's validate our expectations.

```sql
explain analyse select * from students where phone_number like '%130%'
```

No index
```
"Seq Scan on students  (cost=0.00..2420.00 rows=1010 width=62) (actual time=0.012..11.264 rows=895 loops=1)"
"  Filter: ((phone_number)::text ~~ '%130%'::text)"
"  Rows Removed by Filter: 99105"
"Planning Time: 0.071 ms"
"Execution Time: 11.292 ms"
```

BTree
```
"Seq Scan on students  (cost=0.00..2420.00 rows=1010 width=62) (actual time=0.013..11.957 rows=895 loops=1)"
"  Filter: ((phone_number)::text ~~ '%130%'::text)"
"  Rows Removed by Filter: 99105"
"Planning Time: 0.103 ms"
"Execution Time: 11.989 ms"
```

Hash
```
"Seq Scan on students  (cost=0.00..2420.00 rows=1010 width=62) (actual time=0.013..10.819 rows=895 loops=1)"
"  Filter: ((phone_number)::text ~~ '%130%'::text)"
"  Rows Removed by Filter: 99105"
"Planning Time: 0.093 ms"
"Execution Time: 10.846 ms"
```

Gin
```
"Seq Scan on students  (cost=0.00..2420.00 rows=1010 width=62) (actual time=0.015..11.104 rows=895 loops=1)"
"  Filter: ((phone_number)::text ~~ '%130%'::text)"
"  Rows Removed by Filter: 99105"
"Planning Time: 0.087 ms"
"Execution Time: 11.132 ms"
```

Gin trigram
```
"Bitmap Heap Scan on students  (cost=19.83..1211.19 rows=1010 width=62) (actual time=0.132..0.611 rows=895 loops=1)"
"  Recheck Cond: ((phone_number)::text ~~ '%130%'::text)"
"  Heap Blocks: exact=617"
"  ->  Bitmap Index Scan on students_phone_number_gin_trgm  (cost=0.00..19.58 rows=1010 width=0) (actual time=0.078..0.078 rows=895 loops=1)"
"        Index Cond: ((phone_number)::text ~~ '%130%'::text)"
"Planning Time: 0.073 ms"
"Execution Time: 0.643 ms"
```

Gist
```
"Seq Scan on students  (cost=0.00..2420.00 rows=1010 width=62) (actual time=0.013..11.290 rows=895 loops=1)"
"  Filter: ((phone_number)::text ~~ '%130%'::text)"
"  Rows Removed by Filter: 99105"
"Planning Time: 0.049 ms"
"Execution Time: 11.324 ms"
```

Gist trigram
```
"Bitmap Heap Scan on students  (cost=56.11..1247.47 rows=1010 width=62) (actual time=5.095..5.558 rows=895 loops=1)"
"  Recheck Cond: ((phone_number)::text ~~ '%130%'::text)"
"  Heap Blocks: exact=617"
"  ->  Bitmap Index Scan on students_phone_number_gist_trgm  (cost=0.00..55.86 rows=1010 width=0) (actual time=5.036..5.037 rows=895 loops=1)"
"        Index Cond: ((phone_number)::text ~~ '%130%'::text)"
"Planning Time: 0.099 ms"
"Execution Time: 5.592 ms"
```

Yes, we can observe absolutely the same situation.

D) find user with marks by partial surname

```sql
explain analyse select distinct s.student_id, name, surname from students s join exam_results er on s.student_id = er.student_id where surname like '%ram%';
```

No index
```
"Unique  (cost=13574.37..13574.55 rows=9 width=19) (actual time=41.601..43.106 rows=197 loops=1)"
"  ->  Sort  (cost=13574.37..13574.41 rows=18 width=19) (actual time=41.600..43.039 rows=572 loops=1)"
"        Sort Key: s.student_id, s.name, s.surname"
"        Sort Method: quicksort  Memory: 60kB"
"        ->  Gather  (cost=13572.10..13573.99 rows=18 width=19) (actual time=41.425..42.923 rows=572 loops=1)"
"              Workers Planned: 2"
"              Workers Launched: 2"
"              ->  HashAggregate  (cost=12572.10..12572.19 rows=9 width=19) (actual time=39.578..39.601 rows=191 loops=3)"
"                    Group Key: s.student_id, s.name, s.surname"
"                    Batches: 1  Memory Usage: 56kB"
"                    Worker 0:  Batches: 1  Memory Usage: 56kB"
"                    Worker 1:  Batches: 1  Memory Usage: 56kB"
"                    ->  Parallel Hash Join  (cost=1905.36..12571.82 rows=38 width=19) (actual time=4.238..39.250 rows=665 loops=3)"
"                          Hash Cond: (er.student_id = s.student_id)"
"                          ->  Parallel Seq Scan on exam_results er  (cost=0.00..9572.67 rows=416667 width=4) (actual time=0.018..16.661 rows=333333 loops=3)"
"                          ->  Parallel Hash  (cost=1905.29..1905.29 rows=5 width=19) (actual time=4.075..4.075 rows=66 loops=3)"
"                                Buckets: 1024  Batches: 1  Memory Usage: 104kB"
"                                ->  Parallel Seq Scan on students s  (cost=0.00..1905.29 rows=5 width=19) (actual time=0.049..4.018 rows=66 loops=3)"
"                                      Filter: ((surname)::text ~~ '%ram%'::text)"
"                                      Rows Removed by Filter: 33268"
"Planning Time: 0.203 ms"
"Execution Time: 43.136 ms"
```

We see 'like' operator in condition so we already know that it does not make sense to apply any index except trigram and we know that gin trigram is the fastest option, so let's try to speed up this query this way.

Gin trigram on student surname
```
"Unique  (cost=11714.94..11715.12 rows=9 width=19) (actual time=37.607..39.191 rows=197 loops=1)"
"  ->  Sort  (cost=11714.94..11714.99 rows=18 width=19) (actual time=37.606..39.123 rows=578 loops=1)"
"        Sort Key: s.student_id, s.name, s.surname"
"        Sort Method: quicksort  Memory: 60kB"
"        ->  Gather  (cost=11712.68..11714.57 rows=18 width=19) (actual time=37.440..39.003 rows=578 loops=1)"
"              Workers Planned: 2"
"              Workers Launched: 2"
"              ->  HashAggregate  (cost=10712.68..10712.77 rows=9 width=19) (actual time=35.682..35.707 rows=193 loops=3)"
"                    Group Key: s.student_id, s.name, s.surname"
"                    Batches: 1  Memory Usage: 56kB"
"                    Worker 0:  Batches: 1  Memory Usage: 56kB"
"                    Worker 1:  Batches: 1  Memory Usage: 56kB"
"                    ->  Hash Join  (cost=45.93..10712.39 rows=38 width=19) (actual time=1.533..35.377 rows=665 loops=3)"
"                          Hash Cond: (er.student_id = s.student_id)"
"                          ->  Parallel Seq Scan on exam_results er  (cost=0.00..9572.67 rows=416667 width=4) (actual time=0.017..15.816 rows=333333 loops=3)"
"                          ->  Hash  (cost=45.82..45.82 rows=9 width=19) (actual time=1.478..1.479 rows=197 loops=3)"
"                                Buckets: 1024  Batches: 1  Memory Usage: 18kB"
"                                ->  Bitmap Heap Scan on students s  (cost=12.07..45.82 rows=9 width=19) (actual time=0.979..1.442 rows=197 loops=3)"
"                                      Recheck Cond: ((surname)::text ~~ '%ram%'::text)"
"                                      Rows Removed by Index Recheck: 183"
"                                      Heap Blocks: exact=321"
"                                      ->  Bitmap Index Scan on students_surname_gin_trgm  (cost=0.00..12.07 rows=9 width=0) (actual time=0.942..0.942 rows=380 loops=3)"
"                                            Index Cond: ((surname)::text ~~ '%ram%'::text)"
"Planning Time: 0.150 ms"
"Execution Time: 39.229 ms"
```

We can see very small perfomance increase. How can we speed it up further? We know that student_id is primary key in student table and postgres created btree index automatically, so why there is no any perfomance gain? We can see the student_id from exam_results table in another side of the join and there is no created index for that column. Let's create btree index on it.

Gin trigram on student surname + btree index on student_id in exam_results table
```
"HashAggregate  (cost=89.04..89.13 rows=9 width=19) (actual time=1.796..1.817 rows=197 loops=1)"
"  Group Key: s.student_id, s.name, s.surname"
"  Batches: 1  Memory Usage: 56kB"
"  ->  Nested Loop  (cost=12.50..88.36 rows=90 width=19) (actual time=0.081..1.376 rows=1995 loops=1)"
"        ->  Bitmap Heap Scan on students s  (cost=12.07..45.82 rows=9 width=19) (actual time=0.077..0.332 rows=197 loops=1)"
"              Recheck Cond: ((surname)::text ~~ '%ram%'::text)"
"              Rows Removed by Index Recheck: 183"
"              Heap Blocks: exact=321"
"              ->  Bitmap Index Scan on students_surname_gin_trgm  (cost=0.00..12.07 rows=9 width=0) (actual time=0.049..0.049 rows=380 loops=1)"
"                    Index Cond: ((surname)::text ~~ '%ram%'::text)"
"        ->  Index Only Scan using exam_results_student_id_btree on exam_results er  (cost=0.42..4.62 rows=11 width=4) (actual time=0.004..0.004 rows=10 loops=197)"
"              Index Cond: (student_id = s.student_id)"
"              Heap Fetches: 0"
"Planning Time: 0.245 ms"
"Execution Time: 1.845 ms"
```

We can see that query is executed much faster this time.

# Other exercises

## Add trigger that will update column updated_datetime to current date in case of updating any of student.

Let's create a new function:

```sql
create or replace function update_datetime() returns trigger
    language plpgsql
    immutable
as
$$
begin
   new.updated_datetime = now(); 
   return new;
end;
$$
```

Now we can set it as a trigger for each row on students table updates

```sql
create or replace trigger update_students_datetime
before update on students
for each row execute procedure update_datetime();
```

Let's change some value to verify it is executed

```sql
explain analyze update students set name='new_name' where student_id = 1;
```

```
"Update on students  (cost=0.29..8.31 rows=0 width=0) (actual time=0.110..0.111 rows=0 loops=1)"
"  ->  Index Scan using students_pkey on students  (cost=0.29..8.31 rows=1 width=64) (actual time=0.006..0.007 rows=1 loops=1)"
"        Index Cond: (student_id = 1)"
"Planning Time: 0.068 ms"
"Trigger update_students_datetime: time=0.065 calls=1"
"Execution Time: 0.128 ms"
```

We can see the trigger was executed.

## Add validation on DB level that will check username on special characters (reject student name with next characters '@', '#', '$'). 

Let's create such a constraint and try to modify same user name to contain prohibited symbol:

```sql
alter table students drop constraint if exists valid_name
alter table students add constraint valid_name check(name !~* '[@#$]+')
update students set name='new_name@' where student_id = 1
```

The error is raised during name modification:

```
ERROR:  new row for relation "students" violates check constraint "valid_name"
```

## Create snapshot that will contain next data: student name, student surname, subject name, mark (snapshot means that in case of changing some data in source table – your snapshot should not change).

```sql
copy
(select name, surname, subject_name, mark from students s
join exam_results er on s.student_id=er.student_id
join subjects sub on sub.subject_id=er.subject_id)
to '/tmp/snapshot.csv';
```

## Create function that will return average mark for input user.

```sql
create or replace function user_avg(integer) returns numeric
    language plpgsql
    immutable
as
$$
begin
    return (select avg(er.mark) from exam_results as er join students as s on er.student_id = s.student_id where s.student_id = $1);
end;
$$;

select user_avg(100);
```

## Create function that will return avarage mark for input subject name.

```sql
create or replace function subject_avg(text) returns numeric
    language plpgsql
    immutable
as
$$
begin
  return (select avg(er.mark) from exam_results er join subjects s on er.subject_id = s.subject_id where s.subject_name = $1);
end;
$$;

select subject_avg('Confetti and Saw');
```

## Create function that will return student at "red zone" (red zone means at least 2 marks <=3).

It was not clear which student to return from red zone, so I decided to return number of students in the red zone.

```sql
create or replace function red_students() returns integer
    language plpgsql
    immutable
as
$$
begin
	return (select count(student_id) from 
		(select s.student_id, sum(er.mark) from students s
		 join exam_results er on er.student_id = s.student_id
		 where er.mark <= 3 group by s.student_id) as red
	where sum >= 2);
end;
$$;

select red_students();
```